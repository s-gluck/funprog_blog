---
title: "Post 2 - How to Subset Data and Output Basic Descriptives"
description: |
  A tutorial on writing a function to group your data and generate basic descriptives. 
author:
  - name: Stephanie Gluck & Akhila Nekkanti
    url: https://s-gluck.github.io/funprog_blog
date: 05-23-2020
output:
  distill::distill_article:
    self_contained: false
    toc: true
    toc_depth: 2
    highlight: zenburn
---

```{r setup, include= FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(tidyverse)
library(lubridate)
library(glue)
library(janitor)
library(purrr)
library(reactable)

```


# Introduction 

For the tutorial, we will use the [COVID Community Measures](https://www.kaggle.com/gustavomodelli/covid-community-measures) dataset from Kaggle. We hope that you will be able to generalize the function we covered to be applicable to your own dataset. The current dataset contains Community Mobility Reports describing community activities in a variety of settings from Google and the incidence of COVID-19 diagnosis and fatalities from John Hopkins CSSE. 

Community activity is defined as the change in activity from the baseline days. A baseline day is the median value from the 5â€‘week period between January 3rd to February 6th, 2020. 


## Loading the Data 
### Please refer to our blogpost on how to automate your data loading. [You can check out the post here](insert link to Brock's Post)

To create a function that can read in our dataframe and output descriptives, we will need the following packages. If you have not already isntalled them, please use `install.packages(" ")` prior to calling `library()`. 

```{r, echo = TRUE, eval = FALSE}

#At later time, identify what aspects of each library are used for the function
library(tidyverse) 
library(janitor)
library(lubridate)
library(purrr)

```


Once the data is loaded, we can look at the dataframe by using `reactable()`. Notice that you can sort each column by clicking on the column header.

```{r, echo = FALSE}

files <- list.files(here::here("data"),
                    full.names = TRUE)

d <- read_csv(files[1]) %>%
  clean_names()

reactable(d,  
          columns = list(
            country = colDef(name = "Country"),
            date = colDef(name = "Date"),
            grocery_pharmacy = colDef(name = "Grocery Pharmacy"),
            parks = colDef(name = "Parks"),
            residential = colDef(name = "Residential"),
            retail_recreation = colDef(name = "Retail Recreation"),
            transit_stations = colDef(name = "Transit Stations"),
            workplaces = colDef(name = "Workplaces"),
            total_cases = colDef(name = "Total Cases"),
            fatalities = colDef(name = "Fatalities")
          ),
          height = 550,
          striped = TRUE, 
          compact = TRUE, 
          outlined = TRUE,
          searchable = TRUE)


```


We can also look at each of the variable names by calling the R base function `names()`.

```{r variable_names, echo = TRUE}

names(d)

```

& we can look at all the different countries:

```{r countries, echo = TRUE }

#using tidyverse

d %>% 
  count(country, 
        sort = TRUE)

```

# Function Tutorial 

## Subsetting Data 

For this dataset, it would be helpful to create a 'week' variable that extracts each day of the week, so we can group our descriptives by week which would allow us to examine for example the average change in activities across weeks for different settings. Here, we've also created a 'day_of_week'variable to double-check our work. 

If you are working with date-time variables in your data, the [lubridate]("https://lubridate.tidyverse.org/) package is quite powerful at manipulating date-time data. 

```{r echo = TRUE}
#cut.Date, labels = TRUE will print actual day of the week, e.g., Sunday (1)

#use lubridate wday and base R cut.Date

#?cut.Date
#?wday

d <- d %>% 
  mutate(week = cut.Date(date, "week", start.on.monday = FALSE, labels = FALSE), 
         day_of_week = wday(date, label = TRUE))

#taking a look at our new variables `week` and `day_of_week`
d %>% select(country, date, week, day_of_week)

```


Now that we've created our week variable, we can use `tidyr::nest` to group our dataset by week, by country, or both. This will allow us to loop our function through each grouping variable and provide unique descriptives for each. 

We will nest our data by the variables `country` and `week` 

```{r}
#week 7 only has one day  -- filter out here if it becomes a problem

d2 <- d %>%
  group_by(country, week) %>% 
  nest()

print(d2)

```

After nesting, you see that our new dataframe now contains a list-column named `data`. We can call the Argentina Week 1 data tibble to look at it in more details. 

```{r}

d2$data[[1]]

```

You can see that inside the 7 x 11 tibble for Argentina week 1, the community activities, diagnosis, and fatalities data from that week (week of February 23 to February 29, 2020) are listed. 

We can also perform other functions to check our nested dataframe

```{r}
#checking how length of variables
map_dbl(d2$data, nrow)

map_dbl(d2$data, ncol)

#if you want to find the mean for just one specif column, by each country and week. Here we look at the mean for residential for each country across all 7 weeks. 
avg <- map_dbl(d2$data, ~mean(.x$residential))
avg

index <- d2 %>% select(country, week)
index

test <- tibble(index, `residential avg` = avg)
test

```

## General Descriptives with purrr:map

### The functions we have so far are not ideal - need to be cleaned up to be generalized across all numeric columns in a dataset

In order to figure out how to create a function that can be used for any variable in a dataset, we first need to do it for one. 

* `mean` is a base R function.
* `d2` is our nested data set.
* `data` is a dataframe that contains all our other variables, for each country and week. You'll notice there's a different dataset for Argentina week1, Argentina week2, and so on.
* `[[1]]` says: give me the contents within data
* `$residential` specifies which variable within data we are interested in.

```{r, eval = TRUE, echo = TRUE}

mean(d2$data[[1]]$residential)

```

Next, we can attempt to loop through each cell in the 'data' column (that is, grouped by country and week) to find the residential means for each.

```{r, eval = TRUE, echo = TRUE}

residential_mean <- d2 %>% 
  mutate(mean = map_dbl(data, ~mean(.x$residential)))

print(residential_mean)

```


Finally, we can generalize this further to loop through each cell in the data column, to get the mean for each variable in the data frame (not just residential).

1. First, as with any function, we will attempt to create it for just one data frame. Let's call the contents of the first dataset (Argentina Week1) in our nested data frame (`d2`). 

```{r}

tmp <- d2[[3]][[1]]
tmp
```

2. Now you'll notice that some of the columns are not numeric. So we will create a second temporary dataset that calls only the numeric columns by using `map_lgl`. 

```{r}

tmp2 <- tmp[map_lgl(tmp, is.numeric)]
tmp2

```

3. Okay, so now that we have a dataframe with only numeric columns. Let's write a function that gives us just the mean for each column, using `map_dbl` or `map_df`.

```{r}

#map_dbl
map_dbl(tmp2, mean, na.rm = TRUE)
map_dbl

map_df(tmp2, mean, na.rm = TRUE)
map_df

```


4. Now we're ready to create a function that does all of the above, for each column! Let's start by creating a list of all the operations we want our functtion to run with our dataset. Let's call this list `list_of_fun`. Here, we are specifying that we want the total `n` for each column, the `mean`, standard deviation `sd`, `min`, and `max`.

```{r}

listof_fun <- list(
  n = function(x) length(x),
  mean = function(x) mean(x, na.rm = TRUE),
  sd = function(x) sd(x, na.rm = TRUE),
  min = function(x) min(x, na.rm = TRUE),
  max = function(x) max(x, na.rm = TRUE)
  )

```

5. First, let's start with the functions we wrote in steps 2 and 3. We can change the object names to make them more descriptive. Above we used `tmp` because that was the dataset we were interested in making numeric: `numeric_df <- df[map_lgl(df, is.numeric)]`

Here, I am using `df`; once we put this mini-function into our larger function, `df` will refer to all the datasets within our nested dataframe (`d2`). (This will make more sense later) 

Next, we've broadened the function from step 3 so that it can take any dataframe and function as an input, and loop that function throughout the dataset. 

```{r}

#estimating just one function
est_one_fun <- function(df, f) {
 map_dbl(df, ~f(.x))
}

```

6. Almost there! Now let's create our larger function. We'll assign it to the name `descriptives`. Our arguments are:

* `df` = placeholder for a dataframe.

* `funs_to_apply` = a list of functions. We can call this anything. Here we are saying that the list of functions we want is what we created earlier, `listof_fun`.


```{r eval=FALSE}

descriptives <- function(df, funs_to_apply = listof_fun) {
  

```

7. Great, now let's add in the `numeric_df` function we created in step 5. 

```{r eval=FALSE}

descriptives <- function(df, funs_to_apply = listof_fun) {
  
  numeric_df <- df[map_lgl(df, is.numeric)] 


```

8. Now comes the tricky part. We will use `map_df` AND our `est_one_fun` function within our `descriptives` function. Let's focus just on this for now. We are saying: loop through each of our operations in `funs_to_apply`, so that we can apply the `est_one_fun` function to use each of those operations on our `numeric_df`.

```{r eval=FALSE}

#descriptives <- function(df, funs_to_apply = listof_fun) {
  
#  numeric_df <- df[map_lgl(df, is.numeric)] 

  map_df(funs_to_apply, ~est_one_fun(numeric_df, .x)) 

```

9. Phew! Now let's use a bit of `dplyr` code to make our output look nicer. We are using `mutate` to create a vector with each of the column names. Then we are using `select` to change the order of the output so that our names column (`place`) is first.

```{r}

descriptives <- function(df, funs_to_apply = listof_fun) {
  
  numeric_df <- df[map_lgl(df, is.numeric)] 

  map_df(funs_to_apply, ~est_one_fun(numeric_df, .x)) %>% 
    mutate(place = names(numeric_df)) %>% 
    select(place, everything())
}

```


10. Before we celebrate...let's test it! First, on a single dataframe. We can use the one we created in step 1.

```{r}

descriptives(tmp)

```

11. It works!! But can we make it work with our nested dataframe? We'll have to use map again, so that we can loop our `descriptives` function to each element of our list. Let's pipe everything to `d2` and create a new column called `Output` that contains the output from our function. 
```{r}

Descriptive_output <- d2 %>%
  mutate(Output = map(data, descriptives)) %>% 
  select(-data) %>% 
  unnest(Output)

```

Note, we are using `data` within `map` because everything is piped to `d2`. Next, we deselect `data` and unnest so that all we see is our output, country, and week.


## WOOHOO!! WE DID IT.

```{r}


descriptives2 <- function(df, funs_to_apply = list(
                                               n = function(x) length(x),
                                               mean = function(x) mean(x, na.rm = TRUE),
                                               sd = function(x) sd(x, na.rm = TRUE),
                                               min = function(x) min(x, na.rm = TRUE),
                                               max = function(x) max(x, na.rm = TRUE)
  )) {
  
  if(!typeof(funs_to_apply) == "list") {
    funs_to_apply <- list(funs_to_apply)
  }
  if(is.null(names(funs_to_apply))) {
    names(funs_to_apply) <- paste0("f", seq_along(funs_to_apply))
  }
  
  numeric_df <- df[map_lgl(df, is.numeric)] 

  map_df(funs_to_apply, ~est_one_fun(numeric_df, .x)) %>% 
    mutate(place = names(numeric_df)) %>% 
    select(place, everything())
}

descriptives2(tmp2, sd)

map_dbl(list(mean), ~est_one_fun(tmp2, .x))
est_one_fun(tmp2, mean)
is.null(names(list(mean, sd)))
##create new list  of funs to test
funlist <- list(
  n = function(x) length(x),
  mean = function(x) mean(x, na.rm = TRUE),
  sd = function(x) sd(x, na.rm = TRUE))


#test - works!
descriptives2(tmp, funs_to_apply = funlist)

#test
descriptives2(tmp, funs_to_apply = list(mean=mean, sd=sd))

#test with a function

```


```{r}
#loop through our nested list-column df

# METHOD 3 - same as method 2, but did not assign the nested function to its own function (method 2 `est_one_fun`)

#first assign a function
##a) arguments are the dataframe (df) and the list of functions we created (here, we are naming it funs_to_apply, but you can name it anything you want (.funs)), 
### b) we are going to use map_lgl like we did above to select only the numeric columns, and assign to a new object (numeric_df)
### c) we're going to use map_df instead of map_dbl so our output is a data frame. the first map_Df is looping through each of the functions we created (renamed as funs_to_apply in #a), and then rather than specifying a pre-determined function like mean, we are creating our own function here --- map_dbl on our numeric df applies the function to each of these columns, 

desc_df3 <- function(df, funs_to_apply = listof_fun) { #a
  
  numeric_df <- df[map_lgl(df, is.numeric)] #b
  # Method 3
  map_df(funs_to_apply, #c
         function(f) map_dbl(numeric_df, function(col) f(col))) %>% #function(column) f(column) is going through each column and applying function
    mutate(column = names(numeric_df)) %>% 
    select(column, everything())
  
}

#test on a single df
desc_df3(tmp)

#loop through our nested list-column df
d2 %>%
  mutate(descrip = map(data, desc_df3)) %>% 
  select(-data) %>% 
  unnest(descrip)


```

